<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ğŸµ Web DJ Pad ğŸµ</title>
  <style>
    /* --- 1. RGB é›»ç«¶é¢¨æ ¼è¨­å®š --- */
    :root {
      --glass-bg: rgba(20, 20, 30, 0.7);
    }

    /* å®šç¾© RGB æµå…‰å‹•ç•« */
    @keyframes rgbFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* å®šç¾©è‰²ç›¸æ—‹è½‰å‹•ç•« */
    @keyframes hueCycle {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    body {
      background: #000;
      color: #fff;
      font-family: 'Segoe UI', system-ui, sans-serif;
      margin: 0;
      user-select: none;
      -webkit-user-select: none;
      overscroll-behavior: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
      padding: 20px 0;
      box-sizing: border-box;
      position: relative;
    }

    /* å‹•æ…‹èƒŒæ™¯ç¶²æ ¼ - åŠ å…¥ RGB è®Šè‰² */
    body::before {
      content: "";
      position: fixed; top: 0; left: 0; width: 200%; height: 200%;
      background-image: 
        linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 50px 50px;
      transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
      animation: gridMove 20s linear infinite, hueCycle 30s linear infinite;
      z-index: -2;
      pointer-events: none;
    }

    /* èƒŒæ™¯ç²’å­å®¹å™¨ */
    #particles-container {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      z-index: -1; pointer-events: none; overflow: hidden;
    }
    
    .star {
      position: absolute;
      background: #fff;
      border-radius: 50%;
      opacity: 0;
      animation: twinkle linear infinite;
      box-shadow: 0 0 5px #fff;
    }

    @keyframes twinkle {
      0% { opacity: 0; transform: scale(0.5); box-shadow: 0 0 2px rgba(255,0,0,0.8); }
      33% { box-shadow: 0 0 4px rgba(0,255,0,0.8); }
      66% { box-shadow: 0 0 4px rgba(0,0,255,0.8); }
      50% { opacity: 1; transform: scale(1.5); }
      100% { opacity: 0; transform: scale(0.5); }
    }

    @keyframes gridMove {
      0% { transform: perspective(500px) rotateX(60deg) translateY(0) translateZ(-200px); }
      100% { transform: perspective(500px) rotateX(60deg) translateY(50px) translateZ(-200px); }
    }

    /* RGB æ¨™é¡Œ */
    h1 {
      text-align: center;
      margin: 0 0 20px 0;
      font-weight: 900;
      font-size: 2.2rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000);
      background-size: 400%;
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: rgbFlow 8s linear infinite;
      z-index: 10;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));
    }

    /* --- 2. å•Ÿå‹•é®ç½© (RGB Style) --- */
    #startOverlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 9999;
      transition: opacity 0.5s;
    }
    #startOverlay h2 { 
      color: #fff; margin-bottom: 40px; font-size: 2.5rem; 
      text-shadow: 0 0 10px #fff, 0 0 20px #ff00ff, 0 0 30px #00ffff;
      animation: hueCycle 5s infinite linear;
    }
    .start-btn {
      padding: 20px 60px; border-radius: 50px; 
      border: 2px solid transparent;
      background: linear-gradient(#000, #000) padding-box,
                  linear-gradient(45deg, #ff0000, #00ff00, #0000ff, #ff0000) border-box;
      background-size: 400%;
      animation: rgbFlow 10s linear infinite;
      color: #fff; font-size: 1.2rem; font-weight: bold;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      cursor: pointer;
      transition: transform 0.2s;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
    }
    .start-btn:hover {
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
      transform: scale(1.05);
    }

    /* --- 3. æ§åˆ¶é¢æ¿ (RGB Border) --- */
    .panel {
      /* [ä¿®æ­£] ç§»é™¤é€™è¡Œ backgroundï¼Œé¿å…èˆ‡ ::after çš„èƒŒæ™¯ç–ŠåŠ å°è‡´å¤ªé»‘ */
      /* background: var(--glass-bg); */
      
      padding: 20px;
      margin: 0 15px 20px 15px;
      border-radius: 20px;
      display: flex; flex-direction: column; gap: 20px;
      backdrop-filter: blur(20px);
      position: relative;
      width: 100%;
      max-width: 600px;
      box-sizing: border-box;
      z-index: 10;
    }
    
    /* RGB æµå…‰é‚Šæ¡† */
    .panel::before {
      content: "";
      position: absolute;
      top: -3px; left: -3px; right: -3px; bottom: -3px;
      background: linear-gradient(45deg, #ff0000, #ff7300, #fffb00, #48ff00, #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
      background-size: 400%;
      z-index: -2;
      border-radius: 22px;
      animation: rgbFlow 20s linear infinite;
      opacity: 0.8;
      filter: blur(10px);
    }
    /* å¯¦é«”é‚Šæ¡†é®ç½© (é€™è£¡è² è²¬ç»ç’ƒèƒŒæ™¯è‰²) */
    .panel::after {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--glass-bg);
      border-radius: 20px;
      z-index: -1;
    }

    .controls-row { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }

    .control-block {
      background: rgba(0, 0, 0, 0.5);
      padding: 15px; border-radius: 15px;
      display: flex; flex-direction: column; gap: 10px;
      flex: 1; min-width: 250px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
    }

    .block-header {
      display: flex; justify-content: space-between; align-items: center;
      font-size: 0.85rem; color: #fff; font-weight: 700; text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 5px rgba(255,255,255,0.5);
    }

    .value-adjuster { display: flex; align-items: center; gap: 10px; }

    .val-input {
      background: rgba(0,0,0,0.8); border: 1px solid #555;
      color: #00f3ff; width: 50px; text-align: center; border-radius: 5px;
      padding: 4px; font-weight: bold; font-family: monospace;
      box-shadow: 0 0 5px rgba(0, 243, 255, 0.3);
    }

    .adj-btn {
      width: 28px; height: 28px; border-radius: 50%;
      border: 1px solid #555; background: #222;
      color: #00f3ff; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.2s;
    }
    .adj-btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 10px #00f3ff; }

    /* RGB æ»‘æ¡¿è»Œé“ */
    input[type=range] {
      -webkit-appearance: none; width: 100%; height: 6px;
      background: linear-gradient(90deg, #ff0000, #00ff00, #0000ff);
      border-radius: 3px; outline: none; margin: 10px 0;
      opacity: 0.8;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 20px; height: 20px;
      border-radius: 50%; background: #fff; cursor: pointer;
      box-shadow: 0 0 10px #fff;
      transition: transform 0.1s;
    }
    input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.3); box-shadow: 0 0 15px #fff; }

    .presets { display: flex; gap: 5px; justify-content: space-between; }
    .preset-btn {
      flex: 1; padding: 6px 0; font-size: 0.65rem;
      background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px; color: #aaa; cursor: pointer; transition: all 0.2s;
      white-space: nowrap;
    }
    .preset-btn:hover { background: rgba(255,255,255,0.2); color: #fff; border-color: #fff; }

    /* æ¨¡å¼æŒ‰éˆ• (RGB Active Style) */
    .mode-container { display: flex; justify-content: center; gap: 15px; margin-top: 5px; }
    .mode-btn {
      padding: 10px 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 30px;
      cursor: pointer; background: rgba(0,0,0,0.5); color: #ccc; font-weight: bold; font-size: 0.8rem;
      transition: all 0.3s; flex: 1; max-width: 150px;
      position: relative; overflow: hidden; text-align: center;
    }
    .mode-btn:hover { background: rgba(255,255,255,0.1); color: #fff; }
    .mode-btn.active {
      color: #fff;
      border-color: transparent;
      background: linear-gradient(45deg, #ff00cc, #333399);
      box-shadow: 0 0 15px #ff00cc;
      animation: hueCycle 5s infinite linear;
    }

    /* --- 4. Pad ç¶²æ ¼ä½ˆå±€ --- */
    .grid-container {
      display: flex; align-items: center; justify-content: center;
      padding: 0 10px 20px 10px; width: 100%; box-sizing: border-box; perspective: 1000px;
    }

    .grid {
      display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
      width: 100%; max-width: 600px; aspect-ratio: 1/1;
      transform-style: preserve-3d;
    }

    /* --- 5. Pad æœ¬é«” (RGB Style) --- */
    .pad {
      background: rgba(30, 30, 40, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      cursor: pointer; position: relative; overflow: hidden;
      touch-action: none; -webkit-tap-highlight-color: transparent;
      box-shadow: 
        0 4px 6px rgba(0,0,0,0.5), 
        inset 0 1px 0 rgba(255,255,255,0.1);
      transition: transform 0.1s;
    }

    .pad strong {
      font-size: 2rem; pointer-events: none; z-index: 2;
      color: rgba(255,255,255,0.5);
      font-family: 'Courier New', monospace;
      transition: color 0.1s, text-shadow 0.1s;
    }
    .pad-label {
      font-size: 0.75rem; margin-top: 5px; z-index: 2;
      color: rgba(255,255,255,0.4); pointer-events: none;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 90%;
      text-transform: uppercase; letter-spacing: 1px;
    }

    .pad:active { transform: scale(0.95); }
    
    /* Pad è¢«è§¸ç™¼æ™‚çš„ RGB ç˜‹ç‹‚è®Šè‰²æ•ˆæœ */
    .pad.active {
      border-color: #fff;
      animation: rgbBgCycle 2s linear infinite, padPulse 0.1s ease-out;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      z-index: 10;
    }

    @keyframes rgbBgCycle {
      0% { background-color: rgba(255, 0, 0, 0.4); box-shadow: 0 0 30px rgba(255, 0, 0, 0.6); }
      15% { background-color: rgba(255, 127, 0, 0.4); box-shadow: 0 0 30px rgba(255, 127, 0, 0.6); }
      30% { background-color: rgba(255, 255, 0, 0.4); box-shadow: 0 0 30px rgba(255, 255, 0, 0.6); }
      45% { background-color: rgba(0, 255, 0, 0.4); box-shadow: 0 0 30px rgba(0, 255, 0, 0.6); }
      60% { background-color: rgba(0, 0, 255, 0.4); box-shadow: 0 0 30px rgba(0, 0, 255, 0.6); }
      75% { background-color: rgba(75, 0, 130, 0.4); box-shadow: 0 0 30px rgba(75, 0, 130, 0.6); }
      100% { background-color: rgba(148, 0, 211, 0.4); box-shadow: 0 0 30px rgba(148, 0, 211, 0.6); }
    }

    /* éš¨æ©Ÿ Spotlight æ•ˆæœ */
    .pad.spotlight {
      animation: spotlightFlash 0.6s ease-out;
      border-color: rgba(255, 255, 255, 0.8);
    }
    .pad.spotlight strong {
      color: #fff; text-shadow: 0 0 10px #fff;
    }

    @keyframes spotlightFlash {
      0% { background: rgba(255, 255, 255, 0.3); box-shadow: 0 0 20px #fff; transform: scale(1.02); }
      100% { background: rgba(30, 30, 40, 0.8); box-shadow: 0 4px 6px rgba(0,0,0,0.5); transform: scale(1); }
    }
    
    @keyframes padPulse {
      0% { transform: scale(1); } 50% { transform: scale(0.98); } 100% { transform: scale(1); }
    }

    .pad.active strong { color: #fff; text-shadow: 0 0 10px #fff; }
    .pad.active .pad-label { color: #fff; text-shadow: 0 0 5px #fff; }
    .pad.drag-over { border-color: #00ff00; background: rgba(0, 255, 0, 0.2); box-shadow: 0 0 20px #00ff00; }
    .pad.error { border-color: #ff0000; box-shadow: 0 0 20px #ff0000; animation: shake 0.3s ease-in-out; }

    /* é³å°„é€²åº¦æ¢ (RGB è®Šè‰²) */
    .progress-bar {
      position: absolute; bottom: 0; left: 0; height: 5px;
      background: #fff; width: 0%; opacity: 0;
      transition: opacity 0.1s; pointer-events: none;
      box-shadow: 0 0 10px #fff;
      z-index: 5;
      animation: hueCycle 2s linear infinite;
    }
    .pad.active .progress-bar { opacity: 1; }

    /* é»æ“Šæ¼£æ¼ªç‰¹æ•ˆ */
    .ripple {
      position: absolute; border-radius: 50%;
      transform: scale(0);
      animation: ripple 0.6s linear;
      background: rgba(255, 255, 255, 0.5);
      pointer-events: none;
    }
    @keyframes ripple { to { transform: scale(4); opacity: 0; } }

    /* --- å…¶ä»– --- */
    .loading { 
      text-align: center; margin: 10px; color: #fff; 
      font-weight: bold; font-size: 1rem; text-transform: uppercase; letter-spacing: 2px;
      animation: blink 1s infinite;
      text-shadow: 0 0 10px #00f3ff;
    }
    @keyframes blink { 50% { opacity: 0.5; } }
    
    .hint { 
      text-align: center; font-size: 0.8rem; color: rgba(255,255,255,0.5); 
      margin: 10px 0 20px 0; pointer-events: none; font-family: monospace;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); }
    }

    @media (max-width: 600px) {
      body { padding: 10px 0; }
      .grid { gap: 10px; }
      .pad strong { font-size: 1.5rem; }
      .control-block { min-width: 100%; }
      h1 { font-size: 1.5rem; margin-bottom: 15px; }
      .panel { padding: 15px; margin: 0 10px 15px 10px; }
    }
  </style>
</head>
<body>

  <div id="particles-container"></div>

  <div id="startOverlay">
    <h2>ğŸµ Web DJ Pad ğŸµ</h2>
    <button class="start-btn">INITIALIZE SYSTEM / å•Ÿå‹•ç³»çµ±</button>
    <p style="margin-top:30px; opacity:0.7; font-size:0.8rem; color:#fff; font-family:monospace; text-align:center; line-height: 1.6; text-shadow: 0 0 5px #00f3ff;">
      > POLYPHONY MODE: ACTIVE / æ”¯æ´å¤šé‡éŸ³æ•ˆ < <br>
      > RGB ENGINE: MAXIMUM POWER <
    </p>
  </div>

  <h1>ğŸµ Web DJ Pad ğŸµ</h1>
  
  <div class="panel">
    
    <div class="controls-row">
      <div class="control-block">
        <div class="block-header">
          <span>ğŸ”Š MASTER VOLUME / ä¸»éŸ³é‡</span>
          <div class="value-adjuster">
            <input type="number" id="vol-input" class="val-input" min="0" max="100" value="80">
            <span style="color:#aaa; font-size:0.8rem">%</span>
          </div>
        </div>
        <input type="range" id="volume" min="0" max="100" value="80">
        <div class="presets">
          <button class="preset-btn" onclick="updateVolume(0)">MUTE (0)</button>
          <button class="preset-btn" onclick="updateVolume(30)">30</button>
          <button class="preset-btn" onclick="updateVolume(50)">50</button>
          <button class="preset-btn" onclick="updateVolume(80)">80</button>
          <button class="preset-btn" onclick="updateVolume(100)">MAX (100)</button>
        </div>
      </div>

      <div class="control-block">
        <div class="block-header">
          <span>ğŸš€ PITCH CONTROL / é€Ÿåº¦æ§åˆ¶</span>
          <div class="value-adjuster">
            <button class="adj-btn" onclick="adjustPitch(-0.1)">-</button>
            <span id="pitch-val" style="min-width: 40px; text-align: center; color:#fff; font-weight:bold; text-shadow:0 0 5px #00f3ff;">1.0x</span>
            <button class="adj-btn" onclick="adjustPitch(0.1)">+</button>
          </div>
        </div>
        <input type="range" id="pitch" min="0.5" max="2.0" step="0.1" value="1.0">
        <div class="presets">
          <button class="preset-btn" onclick="updatePitch(0.5)">.5x</button>
          <button class="preset-btn" onclick="updatePitch(0.8)">.8x</button>
          <button class="preset-btn" onclick="updatePitch(1.0)">1x</button>
          <button class="preset-btn" onclick="updatePitch(1.2)">1.2x</button>
          <button class="preset-btn" onclick="updatePitch(1.5)">1.5x</button>
          <button class="preset-btn" onclick="updatePitch(2.0)">2x</button>
        </div>
      </div>
    </div>

    <div class="mode-container">
      <button class="mode-btn active" data-mode="normal">NORMAL<br>æ¨™æº–</button>
      <button class="mode-btn" data-mode="loop">LOOP<br>å¾ªç’°</button>
      <button class="mode-btn" data-mode="oneshot">ONE-SHOT<br>å–®æ¬¡</button>
    </div>

  </div>

  <div id="loading" class="loading">LOADING AUDIO ASSETS... / è¼‰å…¥éŸ³æ•ˆè³‡æºä¸­...</div>
  
  <div class="grid-container">
    <div class="grid" id="padGrid"></div>
  </div>
  
  <div class="hint">ğŸ’¡ TIP: MULTI-TOUCH / æç¤ºï¼šæ”¯æ´å¤šé‡éŸ³æ•ˆ</div>

  <script>
    const PAD_KEYS = ["1","2","3","4","A","C","D","E","F","Q","R","S","V","W","X","Z"];
    const DEFAULT_FILES = [
      "1_è¦ªæ„›çš„.mp3", "2_ç¤ºæ„åœè»Š.mp3", "3_å»æ´ªå¹¹å¹¹æ¬¸.mp3", "4_DAMN.mp3",
      "A_For Elise(Oiiai).mp3", "C_Dj Airhorn.mp3", "D_æ˜ŸæœŸäº”æ™šä¸Š.mp3", "E_é»‘é»‘é»‘é»‘.mp3",
      "F_è«‹æ”¯æ´æ”¶éŠ€.mp3", "Q_John Cena.mp3", "R_é˜¿çæ„›ä¸Šäº†é˜¿å¼·.mp3", "S_Young Black&Rich.mp3",
      "V_å‰æ–¹è»Šè¼›è«‹å‘å³é¿è®“.mp3", "W_ç‹è€å…ˆç”Ÿæœ‰å¡Šåœ°.mp3", "X_Airhorn.mp3", "Z_æ–°å¹¹ç·šã‚¨ã‚¢ãƒ›ãƒ¼ãƒ³.mp3"
    ];
    const AUDIO_PATH = "audio/";
    const LOAD_TIMEOUT = 8000;

    let appState = {
      mode: "normal",
      volume: 0.8,
      playbackRate: 1.0
    };
    let isInitialized = false;
    let saveSettingsTimer = null;

    const activeAudios = {}; 
    const runningSounds = new Set();
    
    const preloadedAudios = {};
    const padElements = {};
    const pressedKeys = new Set();
    const progressAnimationIds = {};
    const blobUrls = {};

    function getPadLabel(fname) {
      if (!fname) return "EMPTY";
      try { fname = decodeURIComponent(fname); } catch(e){}
      const match = fname.match(/_(.+)\.\w+$/);
      return match ? match[1] : fname.replace(/\.\w+$/, '');
    }

    function safeSetPointerCapture(el, id) {
      try { 
        if (el.hasPointerCapture && el.hasPointerCapture(id)) return; 
        if (el.setPointerCapture) el.setPointerCapture(id); 
      } catch(e){}
    }
    
    function safeReleasePointerCapture(el, id) {
      try { 
        if (el.hasPointerCapture && !el.hasPointerCapture(id)) return; 
        if (el.releasePointerCapture) el.releasePointerCapture(id); 
      } catch(e){}
    }

    function createRipple(event, element) {
      const circle = document.createElement("span");
      const diameter = Math.max(element.clientWidth, element.clientHeight);
      const radius = diameter / 2;

      let x, y;
      if (event && event.clientX) {
        const rect = element.getBoundingClientRect();
        x = event.clientX - rect.left - radius;
        y = event.clientY - rect.top - radius;
      } else {
        x = element.clientWidth / 2 - radius;
        y = element.clientHeight / 2 - radius;
      }

      circle.style.width = circle.style.height = `${diameter}px`;
      circle.style.left = `${x}px`;
      circle.style.top = `${y}px`;
      circle.classList.add("ripple");

      Array.from(element.getElementsByClassName("ripple")).forEach(r => r.remove());

      circle.addEventListener('animationend', () => {
        circle.remove();
      });

      element.appendChild(circle);
    }

    function initParticles() {
      const container = document.getElementById('particles-container');
      const particleCount = 60;

      for (let i = 0; i < particleCount; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        const size = Math.random() * 3 + 1;
        const delay = Math.random() * 5;
        const duration = Math.random() * 3 + 2;
        
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff', '#ffffff'];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];

        star.style.left = `${x}%`;
        star.style.top = `${y}%`;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.backgroundColor = randomColor;
        star.style.boxShadow = `0 0 5px ${randomColor}`;
        star.style.animationDelay = `${delay}s`;
        star.style.animationDuration = `${duration}s`;

        container.appendChild(star);
      }
    }

    function autoSpotlightLoop() {
      if (!isInitialized) return;

      const count = Math.floor(Math.random() * 4) + 2; 
      
      const keys = [...PAD_KEYS];
      for (let i = keys.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [keys[i], keys[j]] = [keys[j], keys[i]];
      }
      const selectedKeys = keys.slice(0, count);

      selectedKeys.forEach(key => {
        const pad = padElements[key];
        if (pad && !pad.classList.contains('active')) {
          pad.classList.add('spotlight');
          setTimeout(() => pad.classList.remove('spotlight'), 600);
        }
      });

      const nextTime = Math.random() * 1500 + 500;
      setTimeout(autoSpotlightLoop, nextTime);
    }

    function loadSettings() {
      const saved = localStorage.getItem('djPadSettingsPro');
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          appState = { ...appState, ...parsed }; 
          
          updateUIControls(); 
          
          document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === appState.mode);
          });
        } catch(e) { console.error("è¨­å®šè®€å–å¤±æ•—", e); }
      }
    }

    function saveSettings() {
      clearTimeout(saveSettingsTimer);
      saveSettingsTimer = setTimeout(() => {
        localStorage.setItem('djPadSettingsPro', JSON.stringify(appState));
      }, 300);
    }

    async function preloadAudios() {
      const loadingEl = document.getElementById('loading');
      let loadedCount = 0;
      const total = DEFAULT_FILES.length;

      const promises = DEFAULT_FILES.map((file, idx) => {
        return new Promise((resolve) => {
          const key = PAD_KEYS[idx];
          const audio = new Audio();
          let completed = false;
          let timeoutId;

          const done = (success = true) => {
            if (completed) return;
            completed = true;
            
            clearTimeout(timeoutId);
            audio.oncanplaythrough = null;
            audio.onloadeddata = null;
            audio.onerror = null;

            if (success) {
              preloadedAudios[key] = audio;
            } else {
              preloadedAudios[key] = null;
            }

            loadedCount++;
            loadingEl.textContent = `SYSTEM LOADING... ${Math.floor((loadedCount / total) * 100)}%`;
            resolve();
          };

          audio.oncanplaythrough = () => done(true);
          audio.onloadeddata = () => {
            if (audio.readyState >= 2) done(true);
          };
          
          audio.onerror = () => { 
            console.warn(`âš ï¸ ç¼ºæª”: ${file}`);
            done(false);
          };

          timeoutId = setTimeout(() => {
            console.warn(`âš ï¸ è¼‰å…¥è¶…æ™‚: ${file}`);
            done(false);
          }, LOAD_TIMEOUT);

          audio.src = AUDIO_PATH + file;
          audio.preload = 'auto';
          audio.load();
        });
      });

      await Promise.all(promises);
      loadingEl.style.display = 'none';
    }

    function startProgressAnimation(key, audioInstance) {
      if (progressAnimationIds[key]) {
        cancelAnimationFrame(progressAnimationIds[key]);
      }

      const pad = padElements[key];
      const progressBar = pad.querySelector('.progress-bar');

      const update = () => {
        if (activeAudios[key] !== audioInstance) return;

        if (audioInstance.duration && Number.isFinite(audioInstance.duration)) {
          const pct = (audioInstance.currentTime / audioInstance.duration) * 100;
          progressBar.style.width = `${pct}%`;
        }

        if (!audioInstance.paused && !audioInstance.ended) {
          progressAnimationIds[key] = requestAnimationFrame(update);
        }
      };

      progressAnimationIds[key] = requestAnimationFrame(update);
    }

    function playPad(key, event = null) {
      if (!isInitialized) return;

      const pad = padElements[key];
      if (!pad) return;

      createRipple(event, pad);
      
      pad.classList.remove('spotlight');

      if (!preloadedAudios[key]) {
        triggerVisualError(pad);
        return;
      }

      if (appState.mode === "oneshot") {
        stopAllPads(); 
      } else if (appState.mode === "loop") {
        if (activeAudios[key]) {
          stopPad(key); 
          return;
        }
      } 

      const sourceAudio = preloadedAudios[key];
      if (!sourceAudio || !sourceAudio.src) { triggerVisualError(pad); return; }

      const audio = sourceAudio.cloneNode();
      audio.volume = appState.volume;
      audio.playbackRate = appState.playbackRate;
      audio.loop = (appState.mode === "loop");
      audio._padKey = key;

      runningSounds.add(audio);

      audio.onended = () => {
        runningSounds.delete(audio);
        const remainingSounds = [...runningSounds].filter(a => a._padKey === key);

        if (activeAudios[key] === audio) {
          if (remainingSounds.length > 0) {
            const nextAudio = remainingSounds[remainingSounds.length - 1];
            activeAudios[key] = nextAudio;
            startProgressAnimation(key, nextAudio);
          } else {
            delete activeAudios[key];
            pad.classList.remove('active');
            pad.querySelector('.progress-bar').style.width = '0%';
            if (progressAnimationIds[key]) cancelAnimationFrame(progressAnimationIds[key]);
          }
        } else if (remainingSounds.length === 0) {
           pad.classList.remove('active');
           pad.querySelector('.progress-bar').style.width = '0%';
           delete activeAudios[key];
        }
      };

      activeAudios[key] = audio;
      pad.classList.add('active');

      const playPromise = audio.play();
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            if (activeAudios[key] === audio) {
              startProgressAnimation(key, audio);
            }
          })
          .catch(err => {
            console.error(`æ’­æ”¾å¤±æ•—: ${key}`, err);
            runningSounds.delete(audio);
            if (activeAudios[key] === audio) {
              pad.classList.remove('active');
              delete activeAudios[key];
              triggerVisualError(pad);
            }
          });
      }
    }

    function stopPad(key) {
      runningSounds.forEach(audio => {
        if (audio._padKey === key) {
          audio.pause();
          audio.currentTime = 0;
          runningSounds.delete(audio);
        }
      });
      
      if (progressAnimationIds[key]) {
        cancelAnimationFrame(progressAnimationIds[key]);
        delete progressAnimationIds[key];
      }
      
      const pad = padElements[key];
      if (pad) {
        pad.classList.remove('active');
        pad.querySelector('.progress-bar').style.width = '0%';
      }
      delete activeAudios[key];
    }

    function stopAllPads() {
      runningSounds.forEach(audio => {
          audio.pause();
          audio.currentTime = 0;
      });
      runningSounds.clear();
      
      Object.keys(padElements).forEach(key => {
        const pad = padElements[key];
        if (pad) {
            pad.classList.remove('active');
            pad.querySelector('.progress-bar').style.width = '0%';
        }
        if (progressAnimationIds[key]) cancelAnimationFrame(progressAnimationIds[key]);
      });
      
      for (const key in activeAudios) delete activeAudios[key];
    }

    function triggerVisualError(pad) {
      pad.classList.add('error');
      setTimeout(() => pad.classList.remove('error'), 300);
    }

    function setupDragAndDrop(pad, key) {
      pad.ondragover = (e) => { e.preventDefault(); pad.classList.add('drag-over'); };
      pad.ondragleave = (e) => { e.preventDefault(); pad.classList.remove('drag-over'); };

      pad.ondrop = (e) => {
        e.preventDefault();
        pad.classList.remove('drag-over');

        const file = e.dataTransfer.files[0];
        if (file && (file.type.startsWith('audio/') || file.name.match(/\.(mp3|wav|ogg|m4a)$/i))) {
          if (blobUrls[key]) {
            URL.revokeObjectURL(blobUrls[key]);
            delete blobUrls[key];
          }

          const objectUrl = URL.createObjectURL(file);
          blobUrls[key] = objectUrl;
          
          const newAudio = new Audio(objectUrl);
          newAudio.preload = 'auto';
          
          preloadedAudios[key] = newAudio;
          
          const labelEl = pad.querySelector('.pad-label');
          labelEl.textContent = file.name.replace(/\.\w+$/, '');
          labelEl.style.color = "#00f3ff";
          
          pad.style.borderColor = "#00f3ff";
          setTimeout(() => pad.style.borderColor = "rgba(255,255,255,0.1)", 500);
        } else {
          triggerVisualError(pad);
        }
      };
    }

    const padGrid = document.getElementById('padGrid');
    
    PAD_KEYS.forEach((key, idx) => {
      const fname = DEFAULT_FILES[idx];
      const pad = document.createElement('div');
      
      pad.className = "pad";
      pad.innerHTML = `
        <strong>${key}</strong>
        <div class="pad-label">${getPadLabel(fname)}</div>
        <div class="progress-bar"></div>
      `;
      
      pad.setAttribute('role', 'button');
      pad.setAttribute('aria-label', `æ’­æ”¾ ${key}`);
      pad.tabIndex = 0;

      pad.onpointerdown = (e) => {
        e.preventDefault();
        safeSetPointerCapture(pad, e.pointerId);
        playPad(key, e);
      };
      pad.onpointerup = (e) => safeReleasePointerCapture(pad, e.pointerId);
      pad.onpointercancel = (e) => safeReleasePointerCapture(pad, e.pointerId);

      setupDragAndDrop(pad, key);

      padGrid.appendChild(pad);
      padElements[key] = pad;
    });

    function updateVolume(val) {
      let v = parseInt(val);
      if (isNaN(v)) v = 80;
      if (v < 0) v = 0;
      if (v > 100) v = 100;
      
      appState.volume = v / 100;
      
      document.getElementById('volume').value = v;
      document.getElementById('vol-input').value = v;
      
      runningSounds.forEach(audio => audio.volume = appState.volume);
      saveSettings();
    }

    function updatePitch(val) {
      let p = parseFloat(val);
      if (isNaN(p)) p = 1.0;
      if (p < 0.5) p = 0.5;
      if (p > 2.0) p = 2.0;
      
      p = parseFloat(p.toFixed(1));

      appState.playbackRate = p;
      
      document.getElementById('pitch').value = p;
      document.getElementById('pitch-val').textContent = p + "x";
      
      runningSounds.forEach(audio => audio.playbackRate = appState.playbackRate);
      saveSettings();
    }

    function adjustPitch(delta) {
      let newPitch = appState.playbackRate + delta;
      updatePitch(newPitch);
    }

    function updateUIControls() {
      document.getElementById('volume').value = appState.volume * 100;
      document.getElementById('vol-input').value = Math.round(appState.volume * 100);
      
      document.getElementById('pitch').value = appState.playbackRate;
      document.getElementById('pitch-val').textContent = appState.playbackRate + "x";
    }

    document.getElementById('volume').oninput = (e) => updateVolume(e.target.value);
    document.getElementById('vol-input').onchange = (e) => updateVolume(e.target.value);
    
    document.getElementById('pitch').oninput = (e) => updatePitch(e.target.value);

    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.onclick = () => {
        const newMode = btn.dataset.mode;
        
        if (appState.mode !== newMode) {
           stopAllPads();
           appState.mode = newMode;
           
           document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
           btn.classList.add('active');
           
           saveSettings();
        }
      };
    });

    document.addEventListener('keydown', (e) => {
      if (!isInitialized) return;
      if (e.isComposing || e.keyCode === 229) return;
      if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) return;

      const key = e.key.toUpperCase();
      if (pressedKeys.has(key)) return;
      pressedKeys.add(key);

      if (PAD_KEYS.includes(key)) {
        e.preventDefault();
        (e.ctrlKey || e.metaKey) ? stopPad(key) : playPad(key); 
      } else if (e.code === "Space") {
        e.preventDefault();
        stopAllPads();
      }
    });

    document.addEventListener('keyup', (e) => pressedKeys.delete(e.key.toUpperCase()));
    window.addEventListener('blur', () => pressedKeys.clear());

    window.addEventListener('beforeunload', () => {
      Object.values(blobUrls).forEach(url => URL.revokeObjectURL(url));
    });

    const overlay = document.getElementById('startOverlay');
    const startBtn = document.querySelector('.start-btn');
    
    startBtn.onclick = () => {
      isInitialized = true;
      overlay.style.opacity = '0';
      setTimeout(() => overlay.style.display = 'none', 500);
      
      initParticles();
      autoSpotlightLoop();

      // [ä¿®æ­£] è£œä¸Š data: å‰ç¶´ï¼Œç¢ºä¿ iOS å¯è§£é–éŸ³é »
      const silentAudio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
      silentAudio.play().then(() => {
        console.log("âœ… AUDIO SYSTEM ONLINE");
      }).catch(e => {
        console.warn("âš ï¸ AUDIO UNLOCK FAILED:", e);
      });
    };

    loadSettings();
    preloadAudios();

  </script>
</body>
</html>
